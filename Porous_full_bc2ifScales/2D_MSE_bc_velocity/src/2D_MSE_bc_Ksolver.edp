// ----------------------------------------------- COPYRIGHT --------------------------------------
// Copyright 2016-2019
// Ugis Lacis, ugis.lacis@gmail.com
// Shervin Bagheri, shervin.bagheri@mech.kth.se
// -------------------------------------------- LICENSE LGPLv3 ------------------------------------
// This file is part of Porous_full_bc2ifScales.
//
// Porous_full_bc2ifScales is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Porous_full_bc2ifScales is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Porous_full_bc2ifScales. If not, see <http://www.gnu.org/licenses/>.
// ---------------------------------------------- DESCRIPTION -------------------------------------
//
// This software is meant to be executed using FreeFem++. You should have recieved a copy
// of it along with Porous_full_bc2ifScales. If not, get it from <http://www.freefem.org/>.
//
// It has been tested to produce accurate results using FreeFem++ version 4.00.
//
// Execute this file by running "FreeFem++ 2D_MSE_bc_Ksolver.edp" in command line (Unix) or
// open it by graphical FreeFem++ dialogue (Windows).  For more detailed description, consult
// documentation in <doc/> and documentation of FreeFem++.

load "UMFPACK64"
include "2D_MSE_bc_proc.idp"

// Reduce output to minimum
verbosity = 0;

// Number of geometrical entities to include in the computation (not larger than 6)
macro Nstr()5// EOM

real ymin;
real ymax = Nstr;

// Definition of the porous structure
// Need to defined either geomPreset macro (cylinder,laycyl,ellipse) or
// border macros directly. (note - tip of the top structure must be zero!)
macro geomPreset()cylinder// EOM

// Solid volume fraction
real thetas = 0.02;

include "2D_MSE_bc_geom.idp"
// This provides macros defB to define border and genM for mesh generation, as
// well as value for ymin coordinate.

// Mesh resolution
int n=10;
// Interface refinement
int nIntf = 4;
// Structure refinement
int nS = 6;

// Problem index
int indk = 1;

// Sampling rate of vertical distance unit length
int Nsamp = 60;

// Define location of the interface (0 = tip of the upper structure)
// Positive values - rising the interface
real intfShft = 0.1;

// Check that we are above the defined smooth structure (meshing requirement)
assert(intfShft>=0.0001);


// First, define and solve the fully periodic interior Darcy problem, just below the interface cell
// Define the geometry
border sqr1p(t=ymin-1.0,ymin) {x= 0.5;        y=t;                    label=1; }
border sqr2p(t=0.5,-0.5)      {x=t;           y=ymin;                 label=2; }
border sqr3p(t=ymin,ymin-1.0) {x=-0.5;        y=t;                    label=3; }
border sqr4p(t=-0.5,0.5)      {x=t;           y=ymin-1.0;             label=4; }
strBd(Nstr)
// Define the mesh for periodic solution
mesh ThP=buildmesh( sqr1p(n)+sqr2p(nIntf*n)+sqr3p(n)+sqr4p(nIntf*n)+genMi(Nstr) );
// Define the FE spaces for periodic domain and solve for the field
fespace UUPhP(ThP,[P2,P2,P1],periodic=[[2,x],[4,x],[1,y],[3,y]]);
UUPhP [uper,vper,pper], [uper1,vper1,pper1], [uper2,vper2,pper2], [uu,vv,pp];
real[int,int] itrK(2,2);
real[int,int] itfK(2,2);
real[int] avgDiv(2);
problem stokesKi([uper,vper,pper],[uu,vv,pp],solver=sparsesolver) =
    int2d(ThP)( - (-pper + 2.0*dx(uper))*dx(uu) - (dy(uper)+dx(vper))*dy(uu)
                - (-pper + 2.0*dy(vper))*dy(vv) - (dx(vper)+dy(uper))*dx(vv)
                + (dx(uper)+dy(vper))*pp - 1.0e-10*pper*pp )
    + int2d(ThP)( (indk==1)*uu+(indk==2)*vv )
    + on(5,uper=0,vper=0);

indk = 1; stokesKi;
itrK(0,0) = int2d(ThP)(uper);
itrK(1,0) = int2d(ThP)(vper);
avgDiv(0) = int2d(ThP)(dx(uper)+dy(vper))/int2d(ThP)(1.0);
uper1[] = uper[];
indk = 2; stokesKi;
itrK(0,1) = int2d(ThP)(uper);
itrK(1,1) = int2d(ThP)(vper);
avgDiv(1) = int2d(ThP)(dx(uper)+dy(vper))/int2d(ThP)(1.0);
uper2[] = uper[];

// Output information about interior computation
cout << endl;
cout << " ------------------ Interior K computation done ------------------ " << endl;
cout << " itrK/l = " << itrK << endl;
cout << " Average divergence = " << avgDiv << endl;
cout << " ----------------------------------------------------------------- " << endl;

// Define geometry for the interface cell, top
border sqr1ct(t=intfShft,ymax) {x= 0.5; y=t;        label=1; }
border sqr2ct(t=0.5,-0.5)      {x=t;    y=ymax;     label=2; }
border sqr3ct(t=ymax,intfShft) {x=-0.5; y=t;        label=3; }
border sqr4ct(t=-0.5,0.5)      {x=t;    y=intfShft; label=8; } // Interior boundary for jump condition
// bottom
border sqr1cb(t=ymin,intfShft)  {x= 0.5; y=t;        label=1; }
border sqr3cb(t=intfShft,ymin)  {x=-0.5; y=t;        label=3; }
border sqr4cb(t=-0.5,0.5)       {x=t;    y=ymin;     label=4; }
// Define interior solid structures
defB

// Generate mesh
mesh ThC=buildmesh( sqr1ct(n*(ymax-intfShft))+sqr2ct(n)      +sqr3ct(n*(ymax-intfShft))
                   +sqr3cb(n*(intfShft-ymin))+sqr4cb(nIntf*n)+sqr1cb(n*(intfShft-ymin))+genM+sqr4ct(nIntf*n) );
// Mesh for truncation (for some integrals)
mesh ThCt;

// Plot the mesh
plot(ThP,ThC);

// Define the FE space
fespace UUPhC(ThC,[P2,P2,P1],periodic=[[1,y],[3,y]]);
// Define FE functions for problem solution
UUPhC [u,v,p], [u1,v1,p1], [u2,v2,p2], [uuc,vvc,ppc];

// Define the problem
problem stokesKc([u,v,p],[uuc,vvc,ppc],solver=sparsesolver) =
    int2d(ThC)( - (-p + 2.0*dx(u))*dx(uuc) - (dy(u)+dx(v))*dy(uuc)
                - (-p + 2.0*dy(v))*dy(vvc) - (dx(v)+dy(u))*dx(vvc)
                + (dx(u)+dy(v))*ppc  )
    + int2d(ThC)( (y<=intfShft)*((indk==1)*uuc+(indk==2)*vvc) )
    + on(5,u=0,v=0) + on(4,u=uper,v=vper);

// Solve the permeability problem
uper[] = uper1[];
indk = 1; stokesKc;
real avgVu; volAvg(ymax-1,ymax,50,ThC,u) itfK(0,0) = avgVu;
real avgVv; volAvg(ymax-1,ymax,50,ThC,v) itfK(1,0) = avgVv;
avgDiv(0) = int2d(ThC)(dx(u)+dy(v))/int2d(ThC)(1.0);
u1[] = u[];
uper[] = uper2[];
indk = 2; stokesKc;
volAvg(ymax-1,ymax,50,ThC,u) itfK(0,1) = avgVu;
volAvg(ymax-1,ymax,50,ThC,v) itfK(1,1) = avgVv;
avgDiv(1) = int2d(ThC)(dx(u)+dy(v))/int2d(ThC)(1.0);
u2[] = u[];

// Output information about interior computation
cout << endl;
cout << " ---------------- Interface cell computation done ---------------- " << endl;
cout << " Investigated interface location yif = " << intfShft << endl;
cout << " itfK/l = " << itfK << endl;
cout << " Average divergence = " << avgDiv << endl;
cout << " ----------------------------------------------------------------- " << endl << endl;


// Sample the plane average results, adjust number of samples according to vertical height
Nsamp = Nsamp*(ymax-ymin);
real[int,int] PlaneUavg(5,Nsamp);
real          Fslice;
// Create plane average data
for (int i=0; i<Nsamp; i++){
    // Coordinate
    PlaneUavg(0,i) = ymin+1e-6 + i*(ymax-ymin-2e-6)/(Nsamp-1.0);
    // Integral using level set
    if(PlaneUavg(0,i) >= intfShft)
    {
        Fslice         = int1d(ThT,levelset=(y-PlaneUavg(0,i)))(1.0 );
        PlaneUavg(1,i) = int1d(ThT,levelset=(y-PlaneUavg(0,i)))( ut );
        PlaneUavg(2,i) = int1d(ThT,levelset=(y-PlaneUavg(0,i)))( vt );
        PlaneUavg(3,i) = int1d(ThT,levelset=(y-PlaneUavg(0,i)))( pt );
    }
    else
    {
        Fslice         = int1d(ThB,levelset=(y-PlaneUavg(0,i)))(1.0 );
        PlaneUavg(1,i) = int1d(ThB,levelset=(y-PlaneUavg(0,i)))( ub );
        PlaneUavg(2,i) = int1d(ThB,levelset=(y-PlaneUavg(0,i)))( vb );
        PlaneUavg(3,i) = int1d(ThB,levelset=(y-PlaneUavg(0,i)))( pb );
    }
    // Intrinsic plane average of pressure
    PlaneUavg(4,i) = PlaneUavg(3,i) / Fslice;
}
// Save the data to text file
{
    ofstream resfile("2D_bound_cond_Ki"+indk+"prof.txt");
    resfile << "# interface coord = " << intfShft << endl;
    resfile << "# y, <u>_y, <v>_y, <p>_y, <p>^i_y " << endl;
    for (int i=0; i<Nsamp; i++) resfile << PlaneUavg(0,i) << " " << PlaneUavg(1,i) << " " << PlaneUavg(2,i) << " " << PlaneUavg(3,i) << " " << PlaneUavg(4,i) << endl;
}

// // Define the "jet" colorscheme, BUT - it is intensity incorrect (black & white prints look weird)
// real[int] colorsJET = [
//     6.666666666666666297e-01, 1.000000000000000000e+00, 8.333000000000000407e-01,
//     6.666666666666666297e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     6.388833333333332476e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     6.111166666666666414e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     5.833333333333332593e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     5.555499999999999883e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     5.277833333333332710e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     5.000000000000000000e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     4.666586663466538720e-01, 8.333000000000000407e-01, 1.000000000000000000e+00,
//     4.166791660416978571e-01, 6.667000000000000703e-01, 1.000000000000000000e+00,
//     3.333333333333333148e-01, 5.000000000000000000e-01, 1.000000000000000000e+00,
//     2.499875006249687726e-01, 6.667000000000000703e-01, 1.000000000000000000e+00,
//     2.000080003200127854e-01, 8.333000000000000407e-01, 1.000000000000000000e+00,
//     1.666666666666666574e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     1.388833333333333309e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     1.111166666666666553e-01, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     8.333333333333332871e-02, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     5.554999999999999521e-02, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     2.778333333333333002e-02, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     0.000000000000000000e+00, 1.000000000000000000e+00, 1.000000000000000000e+00,
//     0.000000000000000000e+00, 1.000000000000000000e+00, 8.333000000000000407e-01
//     ];
// // Intesity-correct colorscheme
// // Define the "cubehelix" colorscheme, Green-ish (https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/cubetry.html)
// real[int] colorsCUBE = [
//     0.000000000000000000e+00, 0.000000000000000000e+00, 0.000000000000000000e+00,
//     6.474926253687315336e-01, 7.902097902097902082e-01, 1.429999999999999882e-01,
//     6.219336219336218941e-01, 8.587360594795538926e-01, 2.690000000000000169e-01,
//     5.993217054263565435e-01, 9.197860962566843934e-01, 3.739999999999999991e-01,
//     5.784313725490195512e-01, 9.714285714285714191e-01, 4.550000000000000155e-01,
//     5.589192708333332593e-01, 1.000000000000000000e+00, 5.120000000000000107e-01,
//     5.386029411764705621e-01, 1.000000000000000000e+00, 5.440000000000000391e-01,
//     5.150421179302044905e-01, 1.000000000000000000e+00, 5.540000000000000480e-01,
//     4.888888888888889284e-01, 1.000000000000000000e+00, 5.849999999999999645e-01,
//     4.657464212678936732e-01, 9.878787878787879118e-01, 6.600000000000000311e-01,
//     4.437840515106488692e-01, 9.257221458046767104e-01, 7.269999999999999796e-01,
//     4.223227752639516774e-01, 8.467432950191571273e-01, 7.830000000000000293e-01,
//     3.999999999999999667e-01, 7.539203860072376528e-01, 8.289999999999999591e-01,
//     3.755952380952380931e-01, 6.481481481481482509e-01, 8.639999999999999902e-01,
//     3.477192982456139836e-01, 5.337078651685394082e-01, 8.900000000000000133e-01,
//     3.155186064924782041e-01, 4.631463146314631629e-01, 9.090000000000000302e-01,
//     2.861552028218694588e-01, 4.095341278439869614e-01, 9.230000000000000426e-01,
//     2.591397849462365732e-01, 3.311965811965812412e-01, 9.360000000000000542e-01,
//     2.328767123287670826e-01, 2.305263157894736625e-01, 9.499999999999999556e-01,
//     2.050147492625369328e-01, 1.164948453608247309e-01, 9.699999999999999734e-01,
//     0.000000000000000000e+00, 0.000000000000000000e+00, 1.000000000000000000e+00
//     ];

// // Plot the results
// plot(uper,ub,ut,nbiso=80,hsv=colorsJET,fill=1,value=1);
// plot(vper,vb,vt,nbiso=80,hsv=colorsJET,fill=1,value=1);
// plot(pb,pt,nbiso=80,hsv=colorsJET,fill=1,value=1,wait=1);

